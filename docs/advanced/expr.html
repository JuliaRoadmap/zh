<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<title>语法进阶/表达式 - Roadmap</title>
	<meta name="tURL" id="tURL" content="../../"/>
	<meta name="description" content="语法进阶/表达式 - Roadmap">
	<script src="../../extra/info.js"></script><script src='https://giscus.app/client.js' data-repo='JuliaRoadmap/zh' data-repo-id='R_kgDOHQYI2Q' data-category='General' data-category-id='DIC_kwDOHQYI2c4CO2c9' data-mapping='pathname' data-reactions-enabled='1' data-emit-metadata='0' data-input-position='top' data-theme='preferred_color_scheme' data-lang='zh-CN' crossorigin='anonymous' async></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../extra/main.js"></script>
	<link id="theme-href" rel="stylesheet" type="text/css" href="../../css/light.css">
	<link rel="stylesheet" type="text/css" href="../../css/general.css">
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css"/>
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css"/>
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css"/>
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
</head>
<body>
	<div id="documenter">
		<nav class="docs-sidebar"><a class='docs-logo'><img src='../../assets/images/logo.png' alt='logo' height='96' width='144'></a>
			<div class="docs-package-name">
			<span class="docs-autofit">Roadmap</span>
			</div>
			<ul class="docs-menu"></ul>
		</nav>
		<div class="docs-main">
			<header class="docs-navbar">
				<nav class="breadcrumb">
					<ul class="is-hidden-mobile"><li class="is-active">语法进阶 / 表达式</li></ul>
					<ul class="is-hidden-tablet"><li class="is-active">语法进阶 / 表达式</li></ul>
				</nav>
				<div class="docs-right"><a class='docs-edit-link' href='https://github.com/JuliaRoadmap/zh/tree/master/docs/advanced/expr.md' target='_blank'><span class='docs-label is-hidden-touch'>编辑此页面</span></a>
					<a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a>
					<a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a>
				</div>
			</header>
			<article class="content"><h1 id='header-表达式'>表达式<a class='docs-heading-anchor-permalink'></a></h1><p><code>Expr</code> 对象包含两个部分：</p><ul><li><p>一个标识表达式类型的 <code>Symbol</code>，是一个 <a href='https://en.wikipedia.org/wiki/String_interning' target='_blank'>interned string</a> 标识符（下面会有更多讨论）</p></li></ul><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> ex1 = Meta.parse("1 + 1")
:(1 + 1)

julia> typeof(ex1)
Expr

julia> ex1.head
:call
</code></pre></div><br /><ul><li><p>表达式的参数可能是符号、其他表达式或字面量：</p></li></ul><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> ex1.args
3-element Vector{Any}:
  :+
 1
 1
</code></pre></div><br /><p>表达式也可能直接用前置表达式形式构造：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> ex2 = Expr(:call, :+, 1, 1)
:(1 + 1)
</code></pre></div><br /><p>上面构造的两个表达式 – 一个通过解析构造一个通过直接构造 – 是等价的：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> ex1 == ex2
true
</code></pre></div><br /><p><code>dump</code> 可以带有缩进和注释地显示 <code>Expr</code> 对象：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> dump(ex2)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 1
</code></pre></div><br /><p><code>Expr</code> 对象也可以嵌套：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> ex3 = Meta.parse("(4 + 4) / 2")
:((4 + 4) / 2)
</code></pre></div><br /><p>另外一个查看表达式的方法是使用 <code>Meta.show_sexpr</code>，它能显示给定 <code>Expr</code> 的 <a href='https://en.wikipedia.org/wiki/S-expression' target='_blank'>S-expression</a>，对 Lisp 用户来说，这看着很熟悉。下面是一个示例，阐释了如何显示嵌套的 <code>Expr</code>：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> Meta.show_sexpr(ex3)
(:call, :/, (:call, :+, 4, 4), 2)
</code></pre></div><br /><h2 id='header-符号'>符号<a class='docs-heading-anchor-permalink'></a></h2><p>字符 <code>:</code> 在 Julia 中有两个作用。第一种形式构造一个 <code>Symbol</code>，这是作为表达式组成部分的一个 <code>interned string</code>：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> s = :foo
:foo

julia> typeof(s)
Symbol
</code></pre></div><br /><p>构造函数 <code>Symbol</code> 接受任意数量的参数并通过把它们的字符串表示连在一起创建一个新的符号：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> :foo == Symbol("foo")
true

julia> Symbol("func", 10)
:func10

julia> Symbol(:var, '_', "sym")
:var_sym
</code></pre></div><br /><p>注意，要使用 <code>:</code> 语法，符号的名称必须是有效的标识符。否则，必须使用 <code>Symbol(str)</code> 构造函数。</p><p>在表达式的上下文中，符号用来表示对变量的访问；当一个表达式被求值时，符号会被替换为这个符号在合适的 <a href='../basic/scope.html' target='_blank'>作用域</a> 中所绑定的值</p><p>有时需要在 <code>:</code> 的参数两边加上额外的括号，以避免在解析时出现歧义：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> :(:)
:(:)

julia> :(::)
:(::)
</code></pre></div><br /><h2 id='header-引用'>引用<a class='docs-heading-anchor-permalink'></a></h2><p><code>:</code> 的第二个语义是不显式调用 <code>Expr</code> 构造器来创建表达式对象。这被称为<em>引用</em>。<code>:</code> 后面跟着包围着单个 Julia 语句括号，可以基于被包围的代码生成一个 <code>Expr</code> 对象。下面是一个引用算数表达式的例子：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> ex = :(a+b*c+1)
:(a + b * c + 1)

julia> typeof(ex)
Expr
</code></pre></div><br /><p>为了查看这个表达式的结构，可以试一试 <code>ex.head</code> 和 <code>ex.args</code>，或使用 <code>dump</code></p><p>注意等价的表达式也可以使用 <code>Meta.parse</code> 或者直接用 <code>Expr</code> 构造：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia>      :(a + b*c + 1)       ==
       Meta.parse("a + b*c + 1") ==
       Expr(:call, :+, :a, Expr(:call, :*, :b, :c), 1)
true
</code></pre></div><br /><p>解析器提供的表达式通常只有符号、其它表达式和字面量值作为其参数，而由 Julia 代码构造的表达式能以非字面量形式的任意运行期值作为其参数。在此特例中，<code>+</code> 和 <code>a</code> 都是符号，<code>*(b,c)</code> 是子表达式，而 <code>1</code> 是 64 位带符号整数字面量</p><p>引用多个表达式有第二种语法形式：在 <code>quote ... end</code> 中包含代码块</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> ex = quote
           x = 1
           y = 2
           x + y
       end
quote
    #= none:2 =#
    x = 1
    #= none:3 =#
    y = 2
    #= none:4 =#
    x + y
end

julia> typeof(ex)
Expr
</code></pre></div><br /><h2 id='header-插值'>插值<a class='docs-heading-anchor-permalink'></a></h2><p>使用值参数直接构造 <code>Expr</code> 对象虽然很强大，但与<em>通常的</em>Julia 语法相比，<code>Expr</code> 构造函数可能让人觉得乏味。作为替代方法，Julia 允许将字面量或表达式插入到被引用的表达式中。表达式插值由前缀 <code>$</code> 表示</p><p>在此示例中，插入了变量 <code>a</code> 的值：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> a = 1;

julia> ex = :($a + b)
:(1 + b)
</code></pre></div><br /><p>对未被引用的表达式进行插值是不支持的，这会导致编译期错误：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> $a + b
ERROR: syntax: "$" expression outside quote
</code></pre></div><br /><p>在此示例中，元组 <code>(1,2,3)</code> 作为表达式插入到条件测试中：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> ex = :(a in $((1,2,3)) )
:(a in (1, 2, 3))
</code></pre></div><br /><p>在表达式插值中使用 <code>$</code> 是有意让人联想到字符串插值和命令插值。表达式插值使得复杂 Julia 表达式的程序化构造变得方便和易读。</p><h2 id='header-Splatting 插值'>Splatting 插值<a class='docs-heading-anchor-permalink'></a></h2><p>请注意，<code>$</code> 插值语法只允许插入单个表达式到包含它的表达式中。有时，你手头有个由表达式组成的数组，需要它们都变成其所处表达式的参数，而这可通过 <code>$(xs...)</code> 语法做到。例如，下面的代码生成了一个函数调用，其参数数量通过编程确定：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> args = [:x, :y, :z];
julia> :(f(1, $(args...)))
:(f(1, x, y, z))
</code></pre></div><br /><h2 id='header-嵌套引用'>嵌套引用<a class='docs-heading-anchor-permalink'></a></h2><p>自然地，引用表达式可以包含在其它引用表达式中。插值在这些情形中的工作方式可能会有点难以理解。考虑这个例子：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> x = :(1 + 2);

julia> e = quote quote $x end end
quote
    #= none:1 =#
    $(Expr(:quote, quote
    #= none:1 =#
    $(Expr(:$, :x))
end))
end
</code></pre></div><br /><p>注意到表达式中含有 <code>$x</code>，这意味着<code>x</code>还未被<code>评估(evaluate)</code>。换句话说，<code>$</code>表达式属于内部引用表达式，因此使用如下方法时</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> eval(e)
quote
    #= none:1 =#
    1 + 2
end
</code></pre></div><br /><p>但是通过多个 <code>$</code> 也可以实现在外部 <code>quote</code> 表达式将值插入到内部引用表达式的 <code>$</code> 中去</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> e = quote quote $$x end end
quote
    #= none:1 =#
    $(Expr(:quote, quote
    #= none:1 =#
    $(Expr(:$, :(1 + 2)))
end))
end
</code></pre></div><br /><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> eval(e)
quote
    #= none:1 =#
    3
end
</code></pre></div><br /><p>这种行为背后的直觉是每个 <code>$</code> 都将 <code>x</code> 求值一遍：一个 <code>$</code> 工作方式类似于 <code>eval(:x)</code>，其返回 <code>x</code> 的值，而两个 <code>$</code> 行为相当于 <code>eval(eval(:x))</code>。</p><h3 id='header-QuoteNode'>QuoteNode<a class='docs-heading-anchor-permalink'></a></h3><p><code>quote</code> 形式在 AST 中通常表示为一个 head 为 <code>:quote</code> 的 <code>Expr</code></p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> dump(Meta.parse(":(1+2)"))
Expr
  head: Symbol quote
  args: Array{Any}((1,))
    1: Expr
      head: Symbol call
      args: Array{Any}((3,))
        1: Symbol +
        2: Int64 1
        3: Int64 2
</code></pre></div><br /><p>正如我们所看到的，这些表达式支持插值符号 <code>$</code>。但是，在某些情况下，需要在<em>不执行</em>插值的情况下引用代码。这种引用还没有语法，但在内部表示为 <code>QuoteNode</code> 类型的对象：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> eval(Meta.quot(Expr(:$, :(1+2))))
3

julia> eval(QuoteNode(Expr(:$, :(1+2))))
:($(Expr(:$, :(1 + 2))))
</code></pre></div><br /><p>解析器为简单的引用项（如符号）生成 <code>QuoteNode</code>：</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> dump(Meta.parse(":x"))
QuoteNode
  value: Symbol x
</code></pre></div><br /><p><code>QuoteNode</code> 也可用于某些高级的元编程任务</p></article>
			<nav class="docs-footer"><div class='flexbox-break'></div><p class='footer-message'>Powered by <a href='https://github.com/JuliaRoadmap/DoctreePages.jl'>DoctreePages.jl</a> and its dependencies.</p></nav>
			<div class='giscus'></div>
		</div>
	</div>
</body>
</html>
