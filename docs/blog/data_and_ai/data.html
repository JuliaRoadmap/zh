<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<title>数据与人工智能/数据处理 - Roadmap</title>
	<meta name="tURL" id="tURL" content="../../../"/>
	<meta name="description" content="数据与人工智能/数据处理 - Roadmap">
	<script src="../../../extra/info.js"></script><script src='https://giscus.app/client.js' data-repo='JuliaRoadmap/zh' data-repo-id='R_kgDOHQYI2Q' data-category='General' data-category-id='DIC_kwDOHQYI2c4CO2c9' data-mapping='pathname' data-reactions-enabled='1' data-emit-metadata='0' data-input-position='top' data-theme='preferred_color_scheme' data-lang='zh-CN' crossorigin='anonymous' async></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../extra/main.js"></script>
	<link id="theme-href" rel="stylesheet" type="text/css" href="../../../css/light.css">
	<link rel="stylesheet" type="text/css" href="../../../css/general.css">
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css"/>
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css"/>
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css"/>
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
</head>
<body>
	<div id="documenter">
		<nav class="docs-sidebar"><a class='docs-logo'><img src='../../../assets/images/logo.png' alt='logo' height='96' width='144'></a>
			<div class="docs-package-name">
			<span class="docs-autofit">Roadmap</span>
			</div>
			<ul class="docs-menu"></ul>
		</nav>
		<div class="docs-main">
			<header class="docs-navbar">
				<nav class="breadcrumb">
					<ul class="is-hidden-mobile"><li class="is-active">数据与人工智能 / 数据处理</li></ul>
					<ul class="is-hidden-tablet"><li class="is-active">数据与人工智能 / 数据处理</li></ul>
				</nav>
				<div class="docs-right"><a class='docs-edit-link' href='https://github.com/JuliaRoadmap/zh/tree/master/docs/blog/data_and_ai/data.md' target='_blank'><span class='docs-label is-hidden-touch'>编辑此页面</span></a>
					<a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a>
					<a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a>
				</div>
			</header>
			<article class="content"><h1 id='header-数据处理'>数据处理<a class='docs-heading-anchor-permalink'></a></h1><p><img src='/zh/assets/images/data-1.png' alt='alt'></p><h2 id='header-类型扩展'>类型扩展<a class='docs-heading-anchor-permalink'></a></h2><p><img src='/zh/assets/images/data-2.png' alt='alt'></p><p>我们先准备下数据，以波士顿房价为例，不过我们不用<strong>MLJ</strong>的<code>@load_boston</code>了，因为我们有许多工作需要<code>DataFrame</code>来完成</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>using MLJ
using TableView # for showtable

using RDatasets
boston = dataset("MASS", "Boston");
y, X = unpack(boston, col -> col == :MedV, col -> col != :MedV) # MedV 平均房价特征
</code></pre></div><br /><div class='admonition is-info'><header class='admonition-header'>Tips</header><div class='admonition-body'><p>用unpack拆包数据集，可以分别用函数指定需要的数据集</p></div></div><h3 id='header-科学类型'>科学类型<a class='docs-heading-anchor-permalink'></a></h3><h4 id='header-科学类型介绍'>科学类型介绍<a class='docs-heading-anchor-permalink'></a></h4><p><strong>MLJ</strong>扩展出了一系列类型来更好地解释数据集，这种类型叫做<a href='https://alan-turing-institute.github.io/DataScienceTutorials.jl/data/scitype/#type_to_type_coercion' target='_blank'>科学类型</a>科学类型为模型和指标的搜索与查询提供了便利</p><p><strong>模型</strong></p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>models(matching(X,y))
models(matching(X))
</code></pre></div><br /><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>julia> info("RidgeRegressor", pkg="MLJLinearModels")
...
# 输入数据的科学类型
 input_scitype = Table{_s23} where _s23<:(AbstractArray{_s25,1} where _s25<:Continuous),
 # 输出数据的科学类型
 target_scitype = AbstractArray{Continuous,1},
...
</code></pre></div><br /><p><strong>指标</strong></p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>measures(matching(y))

julia> info(l1)
absolute deviations; aliases: `l1`.
...
# 虽然也是target，但这个其实是输入的数据类型
 target_scitype = Union{AbstractArray{Continuous,1}, AbstractArray{Count,1}},
...
</code></pre></div><br /><h4 id='header-查看科学类型'>查看科学类型<a class='docs-heading-anchor-permalink'></a></h4><p>在数据分析中用到科学类型最多的类型有两种，一种是无限数据<code>Infinite</code>，另一种是有限数据<code>Finite</code>这里有<a href='https://alan-turing-institute.github.io/MLJScientificTypes.jl/dev/' target='_blank'>更详细的资料</a><strong>Infinite</strong></p><ol><li><p>Continuous连续数据(其实是小数)</p></li><li><p>Count计数数据(其实跟上面的差不多，只不过是整数)<strong>Finite</strong></p></li><li><p>OrderdedFactor有序的分类数据，像是<code>["bad", "soso", "good"]</code>这样，可以比较</p></li><li><p>Multiclass无序的分类数据，像是<code>["Julia", "Rust", "Clojure"]</code>这样，没有任何联系</p></li></ol><p>通常对数据集(带有特征字段的命名元组和<code>DataFrame</code>)采用<code>schema</code><code> schema(boston)</code></p><table style='float:center'><thead><tr><td>_.names</td><td>_.types</td><td>_.scitypes</td></tr></thead><tbody><tr><td>Crim</td><td>Float64</td><td>Continuous</td></tr><tr><td>Zn</td><td>Float64</td><td>Continuous</td></tr><tr><td>Indus</td><td>Float64</td><td>Continuous</td></tr><tr><td>Chas</td><td>Int64</td><td>Count</td></tr><tr><td>NOx</td><td>Float64</td><td>Continuous</td></tr><tr><td>Rm</td><td>Float64</td><td>Continuous</td></tr><tr><td>Age</td><td>Float64</td><td>Continuous</td></tr><tr><td>Dis</td><td>Float64</td><td>Continuous</td></tr><tr><td>Rad</td><td>Int64</td><td>Count</td></tr><tr><td>Tax</td><td>Int64</td><td>Count</td></tr><tr><td>PTRatio</td><td>Float64</td><td>Continuous</td></tr><tr><td>Black</td><td>Float64</td><td>Continuous</td></tr><tr><td>⋮</td><td>⋮</td><td>⋮</td></tr></tbody></table><p>对没有特征字段的数据可以采用<code>scitype</code><code>scitype([1,2,3])</code><code>AbstractArray{Count, 1}</code></p><h4 id='header-修改科学类型'>修改科学类型<a class='docs-heading-anchor-permalink'></a></h4><p>修改科学类型用<code>coerce</code>，或可以用原地修改的<code>coerce!</code><strong>等等，为什么要修改科学类型？</strong>分析数据时，区分</p><ol><li><p>数据如何编码（例如Int），以及</p></li><li><p>应该如何解释数据（例如，类标签，计数等）</p></li></ol><p>如何被编码的数据将被称为机器类型而数据应如何解释将作为被称为科学型（或scitype）</p><p>但是，在许多其他情况下，可能会有歧义，我们在下面列出一些示例：</p><ol><li><p>Int向量例如[1, 2, ...]，应将其解释为分类标签，</p></li><li><p>Int向量例如[1, 2, ...]，应将其解释为计数数据，</p></li><li><p>String向量["High", "Low", "High", ...]，应将其解释为有序的分类标签，</p></li><li><p>String例如的向量["John", "Maria", ...]，应将其解释为无序的多分类数据</p></li><li><p>浮点向量[1.5, 1.5, -2.3, -2.3]，应将其解释为分类数据（例如，某些设置的几个可能值）等。</p></li></ol><p>为了了解决这种歧异，并更好的对数据集作出解释，我们可以手动修改数据集的科学类型承接上面的例子</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>X = (col_1 = [1,2,3],
	 col_2 = [1,2,3],
	 col_3 = ["High", "Low", "High"],
	 col_4 = ["John", "Maria", "Mike"],
	 col_5 = [1.5, 1.5, -2.3, -2.3])
schema(X)	 
</code></pre></div><br /><table style='float:center'><thead><tr><td>_.name</td><td>_.types</td><td>_.scitypes</td></tr></thead><tbody><tr><td>col_1</td><td>Int64</td><td>Count</td></tr><tr><td>col_2</td><td>Int64</td><td>Count</td></tr><tr><td>col_3</td><td>String</td><td>Textual</td></tr><tr><td>col_4</td><td>String</td><td>Textual</td></tr><tr><td>col_5</td><td>Float64</td><td>Continuous</td></tr></tbody></table><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>Xhat = coerce(X, :col_1 => OrderedFactor, # 这里的分类数据用OrderedFactor来做个例子好了
	      :col_2 => Count, # 可有可无
		  :col_3 => OrderedFactor,
		  :col_4 => Multiclass,
		  :col_5 => Multiclass) 
schema(Xhat)
</code></pre></div><br /><table style='float:center'><thead><tr><td>_.names</td><td>_.types</td><td>_.scitypes</td></tr></thead><tbody><tr><td>col_1</td><td>CategoricalValue{Int64,UInt32}</td><td>OrderedFactor{3}</td></tr><tr><td>col_2</td><td>Int64</td><td>Count</td></tr><tr><td>col_3</td><td>CategoricalValue{String,UInt32}</td><td>OrderedFactor{2}</td></tr><tr><td>col_4</td><td>CategoricalValue{String,UInt32}</td><td>Multiclass{3}</td></tr><tr><td>col_5</td><td>CategoricalValue{Float64,UInt32}</td><td>Multiclass{2}</td></tr></tbody></table><p><strong>那么有没有省力的方法帮助我们修改科学类型？</strong>可以用<code>autotype</code>来指定一些选项，如</p><ol><li><p>:few_to_finite 如果向量中数据很少，但有很多重复的，转为分类类型<code>Finite</code></p></li><li><p>:discrete_to_continuous 将离散的<code>Count</code>, <code>Integer</code>转为<code>Continuous</code></p></li><li><p>:string_to_multiclass 将<code>String</code>变量转为多分类变量举几个例子<code>autotype(X, :few_to_finite)</code></p></li></ol><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>Dict{Symbol,Type} with 5 entries:
  :col_5 => OrderedFactor
  :col_2 => OrderedFactor
  :col_3 => Multiclass
  :col_4 => Multiclass
  :col_1 => OrderedFactor
</code></pre></div><br /><p><code>autotype(X, :discrete_to_continuous)</code></p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>Dict{Symbol,Type} with 2 entries:
  :col_2 => Continuous
  :col_1 => Continuous
</code></pre></div><br /><p><code>autotype(X, :string_to_multiclass)</code></p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>Dict{Symbol,Type} with 2 entries:
  :col_3 => Multiclass
  :col_4 => Multiclass
</code></pre></div><br /><p>如果要传入多个参数，把他们包装起来autotype(X, (:string_to_multiclass, :few_to_finite))</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>Dict{Symbol,Type} with 5 entries:
  :col_5 => OrderedFactor
  :col_2 => OrderedFactor
  :col_3 => Multiclass
  :col_4 => Multiclass
  :col_1 => OrderedFactor
</code></pre></div><br /><p>最后，只用把返回的字典带入<code>coerce</code>中就可以了</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>coerce(X, autotype(X, :string_to_multiclass)) |> schema
</code></pre></div><br /><table style='float:center'><thead><tr><td>_.names</td><td>_.types</td><td>_.scitypes</td></tr></thead><tbody><tr><td>col_1</td><td>Int64</td><td>Count</td></tr><tr><td>col_2</td><td>Int64</td><td>Count</td></tr><tr><td>col_3</td><td>CategoricalArrays.CategoricalValue{String,UInt32}</td><td>Multiclass{2}</td></tr><tr><td>col_4</td><td>CategoricalArrays.CategoricalValue{String,UInt32}</td><td>Multiclass{3}</td></tr><tr><td>col_5</td><td>Float64</td><td>Continuous</td></tr></tbody></table><p><strong>补充</strong>对没有特征字段的数据，<code>coerce</code>直接在写类型参数就可以了: <code>coerce([1,2,3], Continuous) # [1.0, 2.0, 3.0]</code></p><h3 id='header-分类数据'>分类数据<a class='docs-heading-anchor-permalink'></a></h3><p><code>CategoricalArray</code>是为了完善科学类型中的<code>Finite</code>分类类型，专门设计的分类数据</p><h4 id='header-<code>OrderedFactor</code> 有序的分类数据'><code>OrderedFactor</code> 有序的分类数据<a class='docs-heading-anchor-permalink'></a></h4><ol><li><p>转换</p></li></ol><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>julia> x1 = coerce([1,2,3], OrderedFactor)
3-element CategoricalArrays.CategoricalArray{Int64,1,UInt32}:
 1
 2
 3
</code></pre></div><br /><ol><li><p>构造</p></li></ol><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>julia> x2 = categorical([1,2,3], ordered=true)
3-element CategoricalArrays.CategoricalArray{Int64,1,UInt32}:
 1
 2
 3
</code></pre></div><br /><ol><li><p>查看分类顺序</p></li></ol><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>julia> levels(x1)
3-element Array{Int64,1}:
 1
 2
 3
</code></pre></div><br /><ol><li><p>改变分类顺序</p></li></ol><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>julia> levels!(x1, [3,2,1])
3-element CategoricalArrays.CategoricalArray{Int64,1,UInt32}:
 1
 2
 3

julia> levels(x1)
3-element Array{Int64,1}:
 3
 2
 1
</code></pre></div><br /><h4 id='header-Multiclass 无序的分类数据'>Multiclass 无序的分类数据<a class='docs-heading-anchor-permalink'></a></h4><p>在搜索分类模型的时候，如果你细心点，你会发现一些不同</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>info("DecisionTreeClassifier").prediction_type == :probabilistic # true
info("SVMClassifier", pkg="ScikitLearn").prediction_type == :deterministic # true
</code></pre></div><br /><p>其中<code>:probabilistic</code> 指预测时返回的数据是每个分类的概率，如</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>import RDatasets
iris = RDatasets.dataset("datasets", "iris")
y, X = unpack(iris, ==(:Species), colname -> true)
@load DecisionTreeClassifier
tree_model = DecisionTreeClassifier()

tree = machine(tree_model, X, y)
train, test = partition(eachindex(y), 0.7, shuffle = true)
fit!(tree, rows=train)
yhat = predict(tree, rows=test)
</code></pre></div><br /><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code> UnivariateFinite{Multiclass{3}}(setosa=>1.0, versicolor=>0.0, virginica=>0.0)
 UnivariateFinite{Multiclass{3}}(setosa=>0.0, versicolor=>1.0, virginica=>0.0)
 UnivariateFinite{Multiclass{3}}(setosa=>0.0, versicolor=>0.0, virginica=>1.0)
...
</code></pre></div><br /><p>如何获取概率最大的分类呢？？用<code>mode</code>函数</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>mode.(yhat)
</code></pre></div><br /><p><strong>tips</strong>你如果想在预测的时候直接得到分类，就用<code>predict_mode</code></p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>setosa
versicolor
virginica
...
</code></pre></div><br /><p><code>:deterministic</code> 指预测时i返回的数据是单独的一个类别，如</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>@load SVMClassifier pkg=ScikitLearn
clf = fit!(machine(SVMClassifier(), X, y))
yhat = predict(clf, X)
</code></pre></div><br /><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code> "setosa"
 "setosa"
 "setosa"
...
</code></pre></div><br /><p>数据太多，就贴三个把:yum:详细的分类数据文档可以<a href='https://alan-turing-institute.github.io/MLJ.jl/stable/working_with_categorical_data/' target='_blank'>看这里</a></p><p>已有位小伙伴已经翻译好了文档，大家可以看看https://github.com/noob-data-analaysis/data-analysis/blob/master/%5B%E6%95%B0%E6%8D%AE%E5%8F%98%E6%8D%A2%5D%40AquaIndigo/%E6%95%B0%E6%8D%AE%E5%8F%98%E6%8D%A2.md</p><h2 id='header-数据探索'>数据探索<a class='docs-heading-anchor-permalink'></a></h2><p><img src='/zh/assets/images/data-3.png' alt='alt'></p><h3 id='header-总览 <code>showtable</code>'>总览 <code>showtable</code><a class='docs-heading-anchor-permalink'></a></h3><p>showtable(X) # 这个大家在jupyter notebook里试一下就好了，我这里不能导出markdown， 我让别人帮我试了一下也有问题，那就是作者的问题了</p><h3 id='header-查看每列的科学类型 <code>schema</code>'>查看每列的科学类型 <code>schema</code><a class='docs-heading-anchor-permalink'></a></h3><p><code> schema(boston)</code></p><table style='float:center'><thead><tr><td>_.names</td><td>_.types</td><td>_.scitypes</td></tr></thead><tbody><tr><td>Crim</td><td>Float64</td><td>Continuous</td></tr><tr><td>Zn</td><td>Float64</td><td>Continuous</td></tr><tr><td>Indus</td><td>Float64</td><td>Continuous</td></tr><tr><td>Chas</td><td>Int64</td><td>Count</td></tr><tr><td>NOx</td><td>Float64</td><td>Continuous</td></tr><tr><td>Rm</td><td>Float64</td><td>Continuous</td></tr><tr><td>Age</td><td>Float64</td><td>Continuous</td></tr><tr><td>Dis</td><td>Float64</td><td>Continuous</td></tr><tr><td>Rad</td><td>Int64</td><td>Count</td></tr><tr><td>Tax</td><td>Int64</td><td>Count</td></tr><tr><td>PTRatio</td><td>Float64</td><td>Continuous</td></tr><tr><td>Black</td><td>Float64</td><td>Continuous</td></tr><tr><td>⋮</td><td>⋮</td><td>⋮</td></tr></tbody></table><p><strong>注意</strong></p><h3 id='header-自定义查看内容 <code>describe</code>'>自定义查看内容 <code>describe</code><a class='docs-heading-anchor-permalink'></a></h3><p>需要注意的是，<code>describe</code>不能对命名元组起作用，需要<code>DataFrame</code>类型，这个函数是专门为<code>DataFrame</code>设计的</p><h4 id='header-内置功能'>内置功能<a class='docs-heading-anchor-permalink'></a></h4><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>describe(X, :nmissing) # 每一列有missing的数量
13×2 DataFrame
</code></pre></div><br /><table style='float:center'><thead><tr><td>Row</td><td>variable</td><td>nmissing</td></tr></thead><tbody><tr><td></td><td>Symbol</td><td>Nothing</td></tr><tr><td>1</td><td>Crim</td><td></td></tr><tr><td>2</td><td>Zn</td><td></td></tr><tr><td>3</td><td>Indus</td><td></td></tr><tr><td>4</td><td>Chas</td><td></td></tr><tr><td>5</td><td>NOx</td><td></td></tr><tr><td>6</td><td>Rm</td><td></td></tr><tr><td>7</td><td>Age</td><td></td></tr><tr><td>8</td><td>Dis</td><td></td></tr><tr><td>9</td><td>Rad</td><td></td></tr></tbody></table><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>describe(X, :min, :max, :mean, :std) # 每一列的最小值，最大值，平均值，标准差，他们会跳过missing
</code></pre></div><br /><table style='float:center'><thead><tr><td>Row</td><td>variable</td><td>min</td><td>max</td><td>mean</td><td>std</td></tr></thead><tbody><tr><td></td><td>Symbol</td><td>Real</td><td>Real</td><td>Float64</td><td>Float64</td></tr><tr><td>1</td><td>Crim</td><td>0.00632</td><td>88.9762</td><td>3.61352</td><td>8.60155</td></tr><tr><td>2</td><td>Zn</td><td>0.0</td><td>100.0</td><td>11.3636</td><td>23.3225</td></tr><tr><td>3</td><td>Indus</td><td>0.46</td><td>27.74</td><td>11.1368</td><td>6.86035</td></tr><tr><td>4</td><td>Chas</td><td>0</td><td>1</td><td>0.06917</td><td>0.253994</td></tr><tr><td>5</td><td>NOx</td><td>0.385</td><td>0.871</td><td>0.554695</td><td>0.115878</td></tr><tr><td>6</td><td>Rm</td><td>3.561</td><td>8.78</td><td>6.28463</td><td>0.702617</td></tr><tr><td>7</td><td>Age</td><td>2.9</td><td>100.0</td><td>68.5749</td><td>28.1489</td></tr><tr><td>8</td><td>Dis</td><td>1.1296</td><td>12.1265</td><td>3.79504</td><td>2.10571</td></tr><tr><td>9</td><td>Rad</td><td>1</td><td>24</td><td>9.54941</td><td>8.70726</td></tr><tr><td>10</td><td>Tax</td><td>187</td><td>711</td><td>408.237</td><td>168.537</td></tr><tr><td>11</td><td>PTRatio</td><td>12.6</td><td>22.0</td><td>18.4555</td><td>2.16495</td></tr><tr><td>12</td><td>Black</td><td>0.32</td><td>396.9</td><td>356.674</td><td>91.2949</td></tr><tr><td>13</td><td>LStat</td><td>1.73</td><td>37.97</td><td>12.6531</td><td>7.14106</td></tr></tbody></table><h4 id='header-自定义功能'>自定义功能<a class='docs-heading-anchor-permalink'></a></h4><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>desribe(X, :symbol => fn) # fn作用于整个列
</code></pre></div><br /><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>desribe(X, :symbol => sum) 
</code></pre></div><br /><table style='float:center'><thead><tr><td>Row</td><td>variable</td><td>symbol</td></tr></thead><tbody><tr><td></td><td>Symbol</td><td>Real</td></tr><tr><td>1</td><td>Crim</td><td>1828.44</td></tr><tr><td>2</td><td>Zn</td><td>5750.0</td></tr><tr><td>3</td><td>Indus</td><td>5635.21</td></tr><tr><td>4</td><td>Chas</td><td>35</td></tr><tr><td>5</td><td>NOx</td><td>280.676</td></tr><tr><td>6</td><td>Rm</td><td>3180.02</td></tr><tr><td>7</td><td>Age</td><td>34698.9</td></tr><tr><td>8</td><td>Dis</td><td>1920.29</td></tr><tr><td>9</td><td>Rad</td><td>4832</td></tr><tr><td>10</td><td>Tax</td><td>206568</td></tr><tr><td>11</td><td>PTRatio</td><td>9338.5</td></tr><tr><td>12</td><td>Black</td><td>180477.0</td></tr><tr><td>13</td><td>LStat</td><td>6402.45</td></tr></tbody></table><h2 id='header-数据清洗'>数据清洗<a class='docs-heading-anchor-permalink'></a></h2><p><img src='/zh/assets/images/data-4.png' alt='alt'></p><h3 id='header-特征选择 <code>FeatureSelector</code>'>特征选择 <code>FeatureSelector</code><a class='docs-heading-anchor-permalink'></a></h3><p><strong>文档</strong><code>FeatureSelector(features=Symbol[])</code></p><p><strong>注意</strong>这个<code>model</code>用来选择<code>DataFrame</code>或<code>NamedTuple</code>的特征字段</p><p><strong>示例</strong></p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>model = FeatureSelector([:Crim]) # 选择Crim的特征字段
mach = fit!(machine(model, X))
MLJ.transform(mach, X) |> df -> first(df, 5) # 这里的transform会与DataFrame的transform冲突，要指定模块为MLJ
</code></pre></div><br /><p>表格太难打了，我这里就给出5个数据好了</p><table style='float:center'><thead><tr><td>Row</td><td>Crim</td></tr></thead><tbody><tr><td></td><td>Float64</td></tr><tr><td>1</td><td>0.00632</td></tr><tr><td>2</td><td>0.02731</td></tr><tr><td>3</td><td>0.02729</td></tr><tr><td>4</td><td>0.03237</td></tr><tr><td>5</td><td>0.06905</td></tr></tbody></table><h3 id='header-清洗缺失值 <code>FillImputer</code>'>清洗缺失值 <code>FillImputer</code><a class='docs-heading-anchor-permalink'></a></h3><p><strong>文档</strong></p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>FillImputer(
   features        = [],
   continuous_fill = e -> skipmissing(e) |> median
   count_fill      = e -> skipmissing(e) |> (f -> round(eltype(f), median(f)))
   finite_fill     = e -> skipmissing(e) |> mode)
</code></pre></div><br /><p><strong>注意</strong><code>FillImputer</code>可以指定特征列来填充<code>missing</code>值，默认的填充函数以给出，也可以自己定义</p><ul><li><p>continuous_fill: function to use on Continuous data, by default the median</p></li><li><p>count_fill: function to use on Count data, by default the rounded median</p></li><li><p>finite_fill: function to use on Multiclass and OrderedFactor data (including binary data), by default the mode</p></li></ul><p><strong>示例</strong></p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>df = coerce((x1 = 1:3, x2 = [missing, 1, 2]), :x2 => Continuous)
schema(df)
</code></pre></div><br /><table style='float:center'><thead><tr><td>_.name</td><td>_.types</td><td>_.scitype</td></tr></thead><tbody><tr><td>x1</td><td>Int64</td><td>Count</td></tr><tr><td>x2</td><td>Union{Missing, Float64}</td><td>Union{Missing, Continuous}</td></tr></tbody></table><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>model = FillImputer(continuous_fill = e -> skipmissing(e) |> mean)
mach = fit!(machine(model, df))
w = MLJ.transform(mach, df)	
schema(w)
</code></pre></div><br /><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>julia> w = MLJ.transform(mach, df)
(x1 = 1:3,
 x2 = [1.5, 1.0, 2.0],)
</code></pre></div><br /><table style='float:center'><thead><tr><td>_.name</td><td>_.types</td><td>_.scitype</td></tr></thead><tbody><tr><td>x1</td><td>Int64</td><td>Count</td></tr><tr><td>x2</td><td>Union{Missing, Float64}</td><td>Continuous</td></tr></tbody></table><h2 id='header-数据转换'>数据转换<a class='docs-heading-anchor-permalink'></a></h2><p><img src='/zh/assets/images/data-5.png' alt='alt'></p><h3 id='header-数据标准化 <code>Standardizer</code>'>数据标准化 <code>Standardizer</code><a class='docs-heading-anchor-permalink'></a></h3><p><strong>文档</strong><code>Standardizer(; features=Symbol[], ignore=false, ordered_factor=false, count=false)</code></p><div class='display-math tex'>newX = \frac{X' - mean(X)} {Std(X)}</div><p><strong>注意</strong>其中</p><ul><li><p>X'   需要转换的数组</p></li><li><p>X    用来拟合的原数据</p></li><li><p>newX 转换X' 后的新数组</p></li></ul><p>另外<code>Standardizer</code>只对<code>Continuous</code>科学类型的数据有效，如果在数据集中有科学类型为<code>OrderedFactor</code>或<code>Count</code>的<code>nums</code>，可以在<code>Standardizer</code>中指定<code>ordered_factor=true</code>或<code>count=true</code></p><p><strong>示例</strong></p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>X = (ordinal1 = [1, 2, 3],
              ordinal2 = categorical([:x, :y, :x], ordered=true),
              ordinal3 = [10.0, 20.0, 30.0],
              ordinal4 = [-20.0, -30.0, -40.0],
              nominal = categorical(["Your father", "he", "is"]));

schema(X)
</code></pre></div><br /><table style='float:center'><thead><tr><td>_.names</td><td>_.types</td><td>_.scitypes</td></tr></thead><tbody><tr><td>ordinal1</td><td>Int64</td><td>Count</td></tr><tr><td>ordinal2</td><td>CategoricalArrays.CategoricalValue{Symbol,UInt32}</td><td>OrderedFactor{2}</td></tr><tr><td>ordinal3</td><td>Float64</td><td>Continuous</td></tr><tr><td>ordinal4</td><td>Float64</td><td>Continuous</td></tr><tr><td>nominal</td><td>CategoricalArrays.CategoricalValue{String,UInt32}</td><td>Multiclass{3}</td></tr></tbody></table><p>尝试先不把<code>ordinal1</code>转换</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>model = Standardizer()
mach = fit!(machine(model, X))
transform(mach, X)
</code></pre></div><br /><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>(ordinal1 = [1, 2, 3],
 ordinal2 = CategoricalArrays.CategoricalValue{Symbol,UInt32}[:x, :y, :x],
 ordinal3 = [-1.0, 0.0, 1.0],
 ordinal4 = [1.0, 0.0, -1.0],
 nominal = CategoricalArrays.CategoricalValue{String,UInt32}["Your father", "he", "is"],)
</code></pre></div><br /><p>下面我们将<code>Count</code>和<code>OrderedFactor</code>转换不过这里需要对<code>ordered_factor=true</code>另外说明不管这个<code>nums</code>的内容是什么类型，<code>Standardizer</code>都能帮他转换。不过在此之前先会把<code>nums</code>转化为数字数组</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code># 先将X的ordinal2提取出来
temp = X.ordered2
nums = coerce(temp, Count)
# 3-element Array{Int64,1}:
#  1
#  2
#  1

model = UnivariateStandardizer() # UnivariateStandardizer 和 Standardizer 类似, UnivariateStandardizer不能用在命名元组DataFrame上，另外UnivariateStandardizer没有参数，不会忽略Count类型
mach = fit!(machine(model, nums)
transform(mach, nums)```

```julia
 -0.5773502691896256
  1.1547005383792517
 -0.5773502691896256
</code></pre></div><br /><p>验证一下我们的想法</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>model = Standardizer(ordered_factor = true)
mach = fit!(machine(model, X))
transform(mach, X)
</code></pre></div><br /><p>可以看到<code>ordered2</code>那里一毛一样</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>(ordinal1 = [-1.0, 0.0, 1.0],
 ordinal2 = [-0.5773502691896256, 1.1547005383792517, -0.5773502691896256],
 ordinal3 = [-1.0, 0.0, 1.0],
 ordinal4 = [1.0, 0.0, -1.0],
 nominal = CategoricalArrays.CategoricalValue{String,UInt32}["Your father", "he", "is"],)
</code></pre></div><br /><h3 id='header-数据归一化'>数据归一化<a class='docs-heading-anchor-permalink'></a></h3><p>文档里没有找到，可能要自定义模型了</p><h3 id='header-数据离散化'>数据离散化<a class='docs-heading-anchor-permalink'></a></h3><p><strong>A. 连续变量</strong><br /><br />本来连续变量的离散化分为等宽，等频，聚类等，但是在文档里只找到了等宽离散化的<code>UnivariateDiretizer</code></p><p><strong>文档</strong></p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>  UnivariateDiscretizer(n_classes=512)

  Returns an MLJModel for for discretizing any continuous vector v
  (scitype(v) <: AbstractVector{Continuous}), where n_classes describes
  the resolution of the discretization.
</code></pre></div><br /><p><strong>注意</strong><br /><br />等宽离散化，<code>n_classes</code>代表你想分多少个类返回值为分类数组<code>OrderedFactor</code></p><p><strong>示例</strong><br /><br />这里我们对一个<code>1 ~ 100</code>的数组进行等宽离散化，我们把类别设置为10，转换一些随机数</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>data = coerce(1:100, Continuous)
t = UnivariateDiscretizer(n_classes = 10)
discretizer = fit!(machine(t, data))
v = rand(1:100, 10)
w = transform(discretizer, v)
</code></pre></div><br /><table style='float:center'><thead><tr><td>随机数 v</td><td>分类顺序</td></tr></thead><tbody><tr><td>11</td><td>2</td></tr><tr><td>54</td><td>6</td></tr><tr><td>19</td><td>2</td></tr><tr><td>92</td><td>10</td></tr><tr><td>43</td><td>5</td></tr><tr><td>53</td><td>6</td></tr><tr><td>87</td><td>9</td></tr><tr><td>23</td><td>3</td></tr><tr><td>39</td><td>4</td></tr><tr><td>91</td><td>10</td></tr></tbody></table><p><strong>tips</strong>用<code>convert(Vector{Int}, w)</code>获得分类数据的排序情况</p><p><strong>B. 分类变量</strong></p><ol><li><p>有序变量 <code>OrderedFactor</code>在文档里没有这个模型，不过作者告诉我可以用<code>coerce</code>强制转换科学类型如果按原有的分类顺序来转换</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>nums = categorical([:x, :y:, :z], ordered=true)
levels(nums) # 1, 2, 3
coerce(nums, Count) # 1,2,3
coerce(nums, Continuous) # 1.0 2.0 3.0
</code></pre></div><br /><p>也可以改变分类顺序</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>levels!(nums, [:z, :y, :z])
coerce(nums, Count) # 3, 2, 1
</code></pre></div><br /></li><li><p>无序变量 <code>Multiclass</code>有两个模型可以做这个，<code>OneHotEncoder</code>和<code>ContinuousEncoder</code></p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>OneHotEncoder(; features=Symbol[],
    ignore=false,
    ordered_factor=true,
drop_last=false)
</code></pre></div><br /><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>ContinuousEncoder(one_hot_ordered_factors=false, drop_last=false)
</code></pre></div><br /><p><strong>注意</strong>两个模型作用一样，在转换的过程中保留<code>Infinite</code>数据，转换<code>Multiclass</code>数据，不过<code>ContinuousEncoder</code>会丢弃无关的数据，如<code>Textual</code>数据，<code>OneHotEncoder</code>会保留所有特征字段</p><p>额，他们怎么转换我说不清，看代码吧<br /><br /><code>OneHotEncoder</code>:</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>data = (col = ["a", "b", "c"],)
nums = coerce(data, :col => Multiclass{3})
model = OneHotEncoder()
mach = fit!(machine(model, nums))
transform(mach, nums)
</code></pre></div><br /><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>(col__a = [1.0, 0.0, 0.0],
col__b = [0.0, 1.0, 0.0],
col__c = [0.0, 0.0, 1.0],)
</code></pre></div><br /><p><code>ContinuousEncoder</code>:</p><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>data = (col = ["a", "b", "c"],
vals = [1, 2, 3])
schema(data)
</code></pre></div><br /><table style='float:center'><thead><tr><td>_.names</td><td>_.types</td><td>_.scitypes</td></tr></thead><tbody><tr><td>col</td><td>String</td><td>Textual</td></tr><tr><td>vals</td><td>Int64</td><td>Count</td></tr></tbody></table><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>model = ContinuousEncoder()
mach  = fit!(machine(model, data))
transform(mach, data)
</code></pre></div><br /><div data-lang='julia'><div class='codeblock-header'></div><pre class='codeblock-body language-julia'><code>(vals = [1.0, 2.0, 3.0],)
</code></pre></div><br /></li></ol><p>详细文档<a href='https://alan-turing-institute.github.io/MLJ.jl/stable/transformers/' target='_blank'>在这里</a></p></article>
			<nav class="docs-footer"><a class='docs-footer-prevpage' href='tunedmodel.html'>« TunedModel</a><a class='docs-footer-nextpage' href='evaluate.html'>« 评估模型</a><div class='flexbox-break'></div><p class='footer-message'>Powered by <a href='https://github.com/JuliaRoadmap/DoctreePages.jl'>DoctreePages.jl</a> and its dependencies.</p></nav>
			<div class='giscus'></div>
		</div>
	</div>
</body>
</html>
