<!DOCTYPE html>
<html lang="zh">
<head>
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
	<title>数据与人工智能/机器学习算法介绍 - Roadmap</title>
	<meta name="tURL" id="tURL" content="../../../"/>
	<meta name="description" content="数据与人工智能/机器学习算法介绍 - Roadmap">
	<script src="../../../extra/info.js"></script><script src='https://giscus.app/client.js' data-repo='JuliaRoadmap/zh' data-repo-id='R_kgDOHQYI2Q' data-category='General' data-category-id='DIC_kwDOHQYI2c4CO2c9' data-mapping='pathname' data-reactions-enabled='1' data-emit-metadata='0' data-input-position='top' data-theme='preferred_color_scheme' data-lang='zh-CN' crossorigin='anonymous' async></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../extra/main.js"></script>
	<link id="theme-href" rel="stylesheet" type="text/css" href="../../../css/light.css">
	<link rel="stylesheet" type="text/css" href="../../../css/general.css">
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css"/>
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css"/>
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css"/>
	<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">
</head>
<body>
	<div id="documenter">
		<nav class="docs-sidebar"><a class='docs-logo'><img src='../../../assets/images/logo.png' alt='logo' height='96' width='144'></a>
			<div class="docs-package-name">
			<span class="docs-autofit">Roadmap</span>
			</div>
			<ul class="docs-menu"></ul>
		</nav>
		<div class="docs-main">
			<header class="docs-navbar">
				<nav class="breadcrumb">
					<ul class="is-hidden-mobile"><li class="is-active">数据与人工智能 / 机器学习算法介绍</li></ul>
					<ul class="is-hidden-tablet"><li class="is-active">数据与人工智能 / 机器学习算法介绍</li></ul>
				</nav>
				<div class="docs-right"><a class='docs-edit-link' href='https://github.com/JuliaRoadmap/zh/tree/master/docs/blog/data_and_ai/regressor.md' target='_blank'><span class='docs-label is-hidden-touch'>编辑此页面</span></a>
					<a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="设置"></a>
					<a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a>
				</div>
			</header>
			<article class="content"><h1 id='header-机器学习算法介绍'>机器学习算法介绍<a class='docs-heading-anchor-permalink'></a></h1><p>这里简要介绍下各算法和他们之间的关系，详细理解请百度一下</p><h2 id='header-基本算法'>基本算法<a class='docs-heading-anchor-permalink'></a></h2><p>最小二乘法是众多机器学习算法中极为重要的一种基础算法<br /><br />单纯的最小二乘法对于包含噪声的学习过程经常有过拟合的弱点，这往往是由于学习模型对于训练样本而言过于复杂</p><h2 id='header-l2 约束'>l2 约束<a class='docs-heading-anchor-permalink'></a></h2><p>由此，引入带有约束条件的最小二乘法 -— Ridge 回归<br /><br />带有约束条件的最小二乘法和交叉验证法的组合，在实际应用中是非常有效的回归方法<br /><br />然而，当参数特别多的时候，求解各参数以及学习得到的函数的输出值的过程，都需要耗费大量的时间\</p><h2 id='header-l1 约束'>l1 约束<a class='docs-heading-anchor-permalink'></a></h2><p>由此，引入可以吧大部分参数都置为0的稀疏学习算法<br />因为大部分参数都变成了0，所以就可以快速地求解各参数以及学习得到的函数的输出值</p><h2 id='header-l1 + l2 约束'>l1 + l2 约束<a class='docs-heading-anchor-permalink'></a></h2><p>虽然 l1 约束的最小二乘学习法是非常有用的学习方法，但是在实际应用中，经常会遇到些许限制</p><ul><li><p>在 Lasso 回归求解路径中，对于 N×P 的设计矩阵来说，最多只能选出 min(N,p) 个变量<br />当 p&gt;N 的时候，最多只能选出N个预测变量．因此，对于 p∼N 的情况，Lasso方法不能够很好的选出真实的模型．</p></li><li><p>如果预测变量具有群组效应，则用Lasso回 归时，只能选出其中的一个预测变量</p></li><li><p>对于通常的 N&gt;P 的情形，如果预测变量中 存在很强的共线性，Lasso的预测表现受控于岭回归</p></li></ul><p>基于以上几点Lasso回归的局限性，Zou和 Hastie在2005年提出了弹性网回归方法，回归系数表达式为</p><div class='display-math tex'>\hat \beta^{ridge} =\mathop{\arg\min}_{\beta}  \{\sum \limits _{i=1}^{N}(y_i-\beta_0-\sum\limits_{j=1}^px_{ij}\beta_j)^2+\lambda\sum \limits_{j=1}^{p}|\beta_{j}|+\lambda\sum \limits_{j=1}^{p}\beta_{j}^2\}</div><h1 id='header-MLJLinearModels 使用'>MLJLinearModels 使用<a class='docs-heading-anchor-permalink'></a></h1><h2 id='header-Ridge'>Ridge<a class='docs-heading-anchor-permalink'></a></h2><div class='display-math tex'>J = \frac{1}{n}\sum_{i = 1}^n (f( x_i) - y_i)^2 + \lambda \|w\|_2^2\tag{1}</div><p><strong>RidgeRegressor</strong></p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>RidgeRegression()
RidgeRegression(λ; lambda, fit_intercept, penalize_intercept, scale_penalty_with_samples)
</code></pre></div><br /><h2 id='header-Lasso'>Lasso<a class='docs-heading-anchor-permalink'></a></h2><div class='display-math tex'>J = \frac{1}{n}\sum_{i = 1}^n (f( x_i) - y_i)^2 + \lambda \|w\|_1\tag{2}</div><p><strong>LassoRegressor</strong></p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>LassoRegression()
LassoRegression(λ; lambda, fit_intercept, penalize_intercept, scale_penalty_with_samples)
</code></pre></div><br /><h2 id='header-Elastic-Net'>Elastic-Net<a class='docs-heading-anchor-permalink'></a></h2><div class='display-math tex'>\smash{\min_{w}}\sum_{i=1}^m(y_i-\sum_{j=1}^dx_{ij}w_j)^2 + \lambda\sum_{j=1}^d|w_j|+\lambda \sum_{j=1}^dw_j^2 \tag{3}</div><p><strong>ElasticNetRegression</strong></p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>ElasticNetRegression()
ElasticNetRegression(λ)
ElasticNetRegression(λ, γ; lambda, gamma, fit_intercept, penalize_intercept, scale_penalty_with_samples)
</code></pre></div><br /><h2 id='header-说明'>说明<a class='docs-heading-anchor-permalink'></a></h2><p>其实可以不用管</p><ul><li><p><code>fit_intercept</code></p></li><li><p><code>penalize_intercept</code></p></li></ul><p>我也不知道这两个是干什么的，就先别管他们了<br />总之，只用设置 <code>lambda</code> 就行了</p><h1 id='header-实例 波士顿房价预测'>实例 波士顿房价预测<a class='docs-heading-anchor-permalink'></a></h1><h2 id='header-数据准备'>数据准备<a class='docs-heading-anchor-permalink'></a></h2><p>竞赛数据来自 <a href='https://www.kaggle.com/competitions/house-prices-advanced-regression-techniques/overview' target='_blank'>https://www.kaggle.com/competitions/house-prices-advanced-regression-techniques/overview</a></p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>using MLJ, CSV, StableRNGs, MLJLinearModels, Plots
import DataFrames: DataFrame, select, describe
using Statistics    

dataTrain = CSV.read("data/train.csv", DataFrame)
dataTest = CSV.read("data/test.csv", DataFrame)
</code></pre></div><br /><h2 id='header-观察各项主要特征与房价售价的关系'>观察各项主要特征与房价售价的关系<a class='docs-heading-anchor-permalink'></a></h2><h3 id='header-分析 SalePrice'>分析 SalePrice<a class='docs-heading-anchor-permalink'></a></h3><div class='admonition is-info'><header class='admonition-header'>Note</header><div class='admonition-body'><p>存疑</p></div></div><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>julia> describe(dataTrain[!, :SalePrice])
Summary Stats:
Length:         1460
Missing Count:  0
Mean:           180921.195890
Minimum:        34900.000000
1st Quartile:   129975.000000
Median:         163000.000000
3rd Quartile:   214000.000000
Maximum:        755000.000000
Type:           Int64
</code></pre></div><br /><p>通过上面的结果可以知道 <strong>SalePrice</strong> 没有无效或者其他非数值的数据，下面通过图示化来进一步展示 <strong>SalePrice</strong></p><p><img src='../../../assets/images/%E5%AE%9E%E4%BE%8B_%E6%B3%A2%E5%A3%AB%E9%A1%BF%E6%88%BF%E4%BB%B7%E9%A2%84%E6%B5%8B/2022-05-05_19-56-37_screenshot.png' alt='img'></p><p>这里需要一个 <code>distplot</code> 函数来绘制图像</p><ol><li><p>得到数组的 <strong>distribution</strong></p></li><li><p>画出这个分布</p></li></ol><p>然而我还不会这个东西，放一放</p><h3 id='header-分析特征数据'>分析特征数据<a class='docs-heading-anchor-permalink'></a></h3><table style='float:center'><thead><tr>入选特征<td>变量名  数据类型  说明</td><td></td><td></td></tr></thead><tbody><tr><td>LotArea</td><td>Continuous</td><td>地皮面积</td></tr><tr><td>GrLiveArea</td><td>Continuous</td><td>生活面积</td></tr><tr><td>TotalBsmtSF</td><td>Continuous</td><td>地下室总面积</td></tr><tr><td>MiscVal</td><td>Continuous</td><td>其他资产</td></tr><tr><td>GarageCars</td><td>Count</td><td>容纳车辆</td></tr><tr><td>GarageArea</td><td>Continuous</td><td>车库面积</td></tr><tr><td>YearBuilt</td><td>Multiclass</td><td>建造年份</td></tr><tr><td>CentralAir</td><td>Multiclass</td><td>中央空调</td></tr><tr><td>OverallQual</td><td>Multiclass</td><td>总体评价</td></tr><tr><td>Neighborhood</td><td>Multiclass</td><td>地段</td></tr></tbody></table><h3 id='header-验证主要特征是否满足要求'>验证主要特征是否满足要求<a class='docs-heading-anchor-permalink'></a></h3><ol><li><p>类别型特征</p><ol><li><p>CentralAir 中央空调</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>using StatsPlots
let column = :CentralAir
    columnY = dataTrain[!, :SalePrice]
    columnX = dataTrain[!, column]
    boxplot(columnX, columnY) |> display
end
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-03_22-25-14_screenshot.png' alt='img'><br />可以很明显的看到有中央空调的房价明显更高。</p></li><li><p>OverallQual 总体评价</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>let column = :OverallQual
    columnY = dataTrain[!, :SalePrice]
    columnX = dataTrain[!, column]
    boxplot(columnX, columnY) |> display
end
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-03_22-27-36_screenshot.png' alt='img'></p></li><li><p>YearBuilt 建造年份</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>let column = :YearBuilt
    columnY = dataTrain[!, :SalePrice]
    columnX = dataTrain[!, column]
    boxplot(columnX, columnY, size=(2600, 1200)) |> display
end
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-03_22-32-02_screenshot.png' alt='img'></p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>let column = :YearBuilt
    columnY = dataTrain[!, :SalePrice]
    columnX = dataTrain[!, column]
    boxplot(columnX, columnY, size=(2600, 1200)) |> display
    scatter(columnX, columnY, ylim=(0, 800000), size=(1500, 1000)) |> display
end
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-03_22-34-34_screenshot.png' alt='img'></p><p>最开始我是用了箱线图绘制了房价与建造年份的关系，但是并不十分明显，所以又用点图来显示，可以很明显的看到有线性增长的趋势</p></li><li><p>Neighborhood 地段</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>let column = :Neighborhood
    columnY = dataTrain[!, :SalePrice]
    columnX = dataTrain[!, column]
    boxplot(columnX, columnY, size = (1300, 600)) |> display
end
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-03_22-36-46_screenshot.png' alt='img'></p><p>这个该怎么分析呢。。。。。。待定</p></li></ol></li><li><p>数值型特征</p><ol><li><p>LotArea 地表面积</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>let column = :LotArea
    columnY = dataTrain[!, :SalePrice]
    columnX = dataTrain[!, column]
    scatter(columnX, columnY) |> display
end
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-03_22-39-31_screenshot.png' alt='img'><br />好像该特征并没有什么差别，所以不予考虑</p></li><li><p>GrLivArea 生活面积</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>let column = :GrLivArea
    columnY = dataTrain[!, :SalePrice]
    columnX = dataTrain[!, column]
    scatter(columnX, columnY) |> display
end
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-03_22-41-17_screenshot.png' alt='img'></p></li><li><p>TotalBsmtSF 地下室总面积</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>let column = :TotalBsmtSF
    columnY = dataTrain[!, :SalePrice]
    columnX = dataTrain[!, column]
    scatter(columnX, columnY) |> display
end
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-03_22-43-16_screenshot.png' alt='img'></p></li><li><p>MiscVal</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>let column = :MiscVal
    columnY = dataTrain[!, :SalePrice]
    columnX = dataTrain[!, column]
    scatter(columnX, columnY) |> display
end
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-03_22-44-30_screenshot.png' alt='img'></p></li><li><p>GarageArea/GarageCars 车库</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>let columns = [:GarageArea, :GarageCars]
    columnY = dataTrain[!, :SalePrice]
    columnXs = map(column -> dataTrain[!, column], columns)

    for columnX in columnXs
    scatter(columnX, columnY) |> display
    end
end
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-03_22-53-30_screenshot.png' alt='img'></p><p><img src='../../../assets/images/regressor/2022-05-03_22-54-01_screenshot.png' alt='img'><br />由上面点图可以看出房价与车库面积和容纳车辆数呈现线性关系，所以入选主要特征</p></li></ol></li></ol><h2 id='header-更加科学的分析数据'>更加科学的分析数据<a class='docs-heading-anchor-permalink'></a></h2><p>上面的分析可以说非常主观，所以说多多少少还是会不放心，会担心自己选择的特征会不会多了或者少了，<br />又或者选了一些没有太大作用的特征，所以接下来需要进行更加科学的分析<br />为了做到更加科学，我们需要作如下工作：</p><ul><li><p>得到各个特征之间的关系矩阵 – correlation matrix</p></li><li><p>SalePrice 的关系矩阵</p></li><li><p>绘制出最相关的特征之间的关系图</p></li></ul><h3 id='header-关系矩阵'>关系矩阵<a class='docs-heading-anchor-permalink'></a></h3><p>教程中有局限性， <strong>关系矩阵只涉及到数值型数据</strong> ，这里我们也这样做，因为他的特征数有80多个，我懒得弄</p><div data-lang=''><div class='codeblock-header'></div><pre class='codeblock-body language-'><code>let _schema = schema(dataTrain)
    _names = _schema.names
    _scitypes = _schema.scitypes
    indexs = collect(map(x -> x == Count || x == Continuous, _scitypes))
    columns = _names[indexs] |> collect
    _data = select(dataTrain, columns)
    _corr = cor(Matrix(_data))
    labels = string.(columns)
    heatmap(labels, labels, _corr, xrotation = -90, size = figureSize, xticks = :all, yticks = :all) |> display
end
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-04_21-11-07_screenshot.png' alt='img'><br />像素块越亮表示两者之间相关性越强，我们可以很清楚地看到与“SalePrice”相关性很强的有</p><ul><li><p><code>OverallQual</code> 总评价</p></li><li><p><code>YearBuilt</code> 建造年份</p></li><li><p><code>ToatlBsmtSF</code> 地下室面积</p></li><li><p><code>1stFlrSF</code> 一楼面积</p></li><li><p><code>GrLiveArea</code> 生活区面积</p></li><li><p><code>FullBath</code> 浴室？what。。。到底什么意思，知道的麻烦说一下</p></li><li><p><code>TotRmsAbvGrd</code> 总房间数（不包括浴室）</p></li><li><p><code>GarageCars</code> 车库可容纳车辆数</p></li><li><p><code>GarageArea</code> 车库面积</p></li></ul><h3 id='header-[存疑]房价关系矩阵'>[存疑]房价关系矩阵<a class='docs-heading-anchor-permalink'></a></h3><p>这里显示相关性最大的10个特征</p><div data-lang=''><div class='codeblock-header'></div><pre class='codeblock-body language-'><code>k  = 10 # 关系矩阵中将显示10个特征
cols = corrmat.nlargest(k, 'SalePrice')['SalePrice'].index
cm = np.corrcoef(data_train[cols].values.T)
sns.set(font_scale=1.25)
hm = sns.heatmap(cm, cbar=True, annot=True, \
		 square=True, fmt='.2f', annot_kws={'size': 10}, yticklabels=cols.values, xticklabels=cols.values)
plt.show()
</code></pre></div><br /><p>我不知道这个代码是怎么运行的，他是怎么画出这个热力图的</p><p><img src='../../../assets/images/regressor/2022-05-05_18-23-15_screenshot.png' alt='img'></p><p><strong>重点是 <code>corrmat.nlargestk</code> 是怎么得出 10x10 的矩阵</strong></p><p>我只做到这里</p><div data-lang=''><div class='codeblock-header'></div><pre class='codeblock-body language-'><code>let _schema = schema(dataTrain)
    _names = _schema.names
    _scitypes = _schema.scitypes
    indexs = collect(map(x -> x == Count || x == Continuous, _scitypes))
    columns = _names[indexs] |> collect
    labels = string.(columns)
    _data = select(dataTrain, columns)
    _corr = cor(Matrix(_data))

    _dataframe = DataFrame(_corr, columns)
    nlarget = _dataframe[partialsortperm(_dataframe[!, :SalePrice], 1:10, rev=true), :]

    heatmap(Matrix(nlarget), xrotation = -90, size = figureSize, xticks = :all, yticks = :all, aspect_ratio = :equal)

    nrow, ncol = size(_corr)
    fontsize = 15

    fn(tuple) = (tuple[1], tuple[2], text(round(_corr[tuple[1], tuple[2]], digits = 2), fontsize, :white, :center))
    ann = map(fn, Iterators.product(1:nrow, 1:ncol) |> collect |> vec)

    annotate!(ann, linecolor = :white) |> display
end
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-05_18-58-23_screenshot.png' alt='img'></p><p>疑点如下</p><ol><li><p>如何获取 <code>Dataframe</code> 最大的 10x10 切片</p></li><li><p><code>Dataframe</code> 的字段名也要根据数据排序进行修改吧？</p></li></ol><h3 id='header-[存疑]绘制关系点图'>[存疑]绘制关系点图<a class='docs-heading-anchor-permalink'></a></h3><p>目前找到一个 <code>PairPlots</code> 包，我还要研究一下</p><h2 id='header-开始模拟数据'>开始模拟数据<a class='docs-heading-anchor-permalink'></a></h2><h3 id='header-处理数据'>处理数据<a class='docs-heading-anchor-permalink'></a></h3><ol><li><p>首先我们选取特征</p><div data-lang=''><div class='codeblock-header'></div><pre class='codeblock-body language-'><code>columns = [:OverallQual, :GrLivArea, :GarageCars, :TotalBsmtSF, :FullBath, :TotRmsAbvGrd, :YearBuilt]
</code></pre></div><br /></li><li><p>定义训练集的处理模型</p><div data-lang=''><div class='codeblock-header'></div><pre class='codeblock-body language-'><code>trainTransformModel = Pipeline(
    FeatureSelector(features = columns),
    dataframe -> coerce(dataframe, Count => Continuous))
</code></pre></div><br /></li><li><p>定义测试集的处理模型</p><div data-lang=''><div class='codeblock-header'></div><pre class='codeblock-body language-'><code>processFeature!(dataframe::DataFrame) = begin
    dataframe[!, :GarageCars] = replace(dataframe[!, :GarageCars], "NA" => missing)
    dataframe[!, :GarageCars] = map(x -> ismissing(x) ? x : parse(Float64, x), dataframe[!, :GarageCars])
    dataframe[!, :TotalBsmtSF] = replace(dataframe[!, :TotalBsmtSF], "NA" => missing)
    dataframe[!, :TotalBsmtSF] = map(x -> ismissing(x) ? x : parse(Float64, x), dataframe[!, :TotalBsmtSF])

    coerce!(dataframe, Count => Continuous)
    return dataframe
end

testTransformModel = Pipeline(
    FeatureSelector(features = columns),
    processFeature!,
    FillImputer(features = columns),
    # Standardizer(features = columns)
)
</code></pre></div><br /></li><li><p>处理原始数据，产出数据集</p><div data-lang=''><div class='codeblock-header'></div><pre class='codeblock-body language-'><code>trainTransformMach = machine(trainTransformModel, dataTrain)
testTransformMach = machine(testTransformModel, dataTest)
fit!(trainTransformMach)
fit!(testTransformMach)

transformedDataTrain = transform(trainTransformMach, dataTrain)
transformedDataTest = transform(testTransformMach, dataTest)
</code></pre></div><br /></li><li><p>拿出训练用数据</p><div data-lang=''><div class='codeblock-header'></div><pre class='codeblock-body language-'><code>X = transformedDataTrain
y = coerce(dataTrain[!, :SalePrice], Continuous)
train, test = partition(eachindex(y), 0.8, rng=rng)
</code></pre></div><br /></li></ol><h3 id='header-模型训练'>模型训练<a class='docs-heading-anchor-permalink'></a></h3><p>这里我们使用 <strong>Ridge</strong> 模型来检验</p><div data-lang=''><div class='codeblock-header'></div><pre class='codeblock-body language-'><code>rng = StableRNG(1234)
cv = CV(nfolds = 6, rng = rng)
tuning = Grid(resolution=10, rng = rng)

# MODULE try Ridge
ridge = RidgeRegressor()
rangeLambda = range(ridge, :lambda, lower = 0.1, upper = 10.0, scale=:log)


tunedModel = TunedModel(model = ridge,
			range = [rangeLambda],
			measure = rms,
			resampling = cv,
			tuning = tuning)
tunedMach = machine(tunedModel, X, y)
fit!(tunedMach, rows = train)

evaluate!(tunedMach, resampling = cv, measure = [rms, l1], rows = test)
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-05_19-24-51_screenshot.png' alt='img'></p><h3 id='header-补充: lightGBM 模型训练'>补充: lightGBM 模型训练<a class='docs-heading-anchor-permalink'></a></h3><div data-lang=''><div class='codeblock-header'></div><pre class='codeblock-body language-'><code>LGBMRegressor = @load LGBMRegressor
lgb = LGBMRegressor()
lgbm = machine(lgb, X, y)
boostRange = range(lgb, :num_iterations, lower = 2, upper = 500)
rangeLeaf = range(lgb, :min_data_in_leaf, lower = 1, upper = 50)
rangeIteration = range(lgb, :num_iterations, lower = 50, upper = 100)
rangeMinData = range(lgb, :min_data_in_leaf, lower = 2, upper = 10)
rangeLearningRate = range(lgb, :learning_rate, lower = 0.1, upper = 1)

tunedModel = TunedModel(model = lgb,
			tuning = Grid(resolution = 5, rng = rng),
			resampling = cv,
			ranges = [rangeIteration, rangeMinData, rangeLearningRate],
			measure = rms)

tunedMachine = machine(tunedModel, X, y)
fit!(tunedMachine, rows = train)
evaluate!(tunedMach, resampling = cv, measure = [rms, l1], rows = test)
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-05_19-29-43_screenshot.png' alt='img'></p><h2 id='header-检验测试集数据'>检验测试集数据<a class='docs-heading-anchor-permalink'></a></h2><p>这里我们用 <strong>lightGBM</strong> 产出的数据来提交，不得不说，这个模型老牛逼了</p><div data-lang='jl'><div class='codeblock-header'></div><pre class='codeblock-body language-jl'><code>predictions = predict(tunedMachine, transformedDataTest)
output = DataFrame(Id=dataTest.Id)
output[!, :SalePrice] = predictions
CSV.write("data/submission.csv", output)
</code></pre></div><br /><p><img src='../../../assets/images/regressor/2022-05-05_19-31-25_screenshot.png' alt='img'></p></article>
			<nav class="docs-footer"><a class='docs-footer-prevpage' href='introduction.html'>« 数据分析简介</a><a class='docs-footer-nextpage' href='models.html'>« 模型搜索</a><div class='flexbox-break'></div><p class='footer-message'>Powered by <a href='https://github.com/JuliaRoadmap/DoctreePages.jl'>DoctreePages.jl</a> and its dependencies.</p></nav>
			<div class='giscus'></div>
		</div>
	</div>
</body>
</html>
